name: Release Obsidian plugin

on:
  push:
    tags:
      - "*"

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20.x"
          cache: "npm"

      - name: Install system dependencies
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Extract version from git tag
        id: get_version
        run: |
          set -e  # Exit immediately if a command fails
          tag="${GITHUB_REF#refs/tags/}"
          # Strip leading 'v' prefix if present (e.g., v0.0.10 -> 0.0.10)
          version="${tag#v}"
          echo "Git tag: $tag"
          echo "Semantic version: $version"

          # Validate semantic version format (X.Y.Z or X.Y.Z-prerelease)
          if ! [[ "$version" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.]+)?$ ]]; then
            echo "Error: Invalid semantic version format: $version"
            echo "Expected format: X.Y.Z or X.Y.Z-prerelease (e.g., 1.0.0 or 1.0.0-beta.1)"
            exit 1
          fi

          # Export to GITHUB_ENV for use in subsequent steps
          echo "VERSION=$version" >> $GITHUB_ENV
          echo "GIT_TAG=$tag" >> $GITHUB_ENV

      - name: Set version in manifest
        run: |
          set -e  # Exit immediately if a command fails
          # Replace __VERSION__ template with actual version from git tag
          # Note: This modifies manifest.json in the build environment only.
          # The source repository retains the __VERSION__ template for future releases.
          sed -i "s|__VERSION__|$VERSION|g" manifest.json
          echo "Updated manifest.json:"
          cat manifest.json

      - name: Update versions.json
        run: |
          set -e  # Exit immediately if a command fails

          # Verify versions.json exists
          if [ ! -f versions.json ]; then
            echo "Error: versions.json not found"
            exit 1
          fi

          # Extract minAppVersion from manifest
          min_app_version=$(jq -r '.minAppVersion' manifest.json) || {
            echo "Error: Failed to read minAppVersion from manifest.json"
            exit 1
          }

          # Add new version entry to versions.json
          # Note: Uses temp_versions.json to avoid file corruption during jq processing
          jq --arg version "$VERSION" --arg minVer "$min_app_version" \
            '. + {($version): $minVer}' versions.json > temp_versions.json || {
            echo "Error: Failed to update versions.json"
            exit 1
          }
          mv temp_versions.json versions.json

          echo "Updated versions.json:"
          cat versions.json

      - name: Verify version substitution
        run: |
          set -e  # Exit immediately if a command fails
          if grep -q "__VERSION__" manifest.json; then
            echo "Error: __VERSION__ template not replaced in manifest.json"
            exit 1
          fi
          echo "Version substitution verified successfully"

      - name: Commit versions.json to repository
        run: |
          set -e  # Exit immediately if a command fails
          # Configure git for the workflow
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Restore manifest.json to keep __VERSION__ template in source
          git checkout manifest.json

          # Commit only versions.json with the new version entry
          git add versions.json
          if git diff --staged --quiet; then
            echo "No changes to versions.json, skipping commit"
          else
            git commit -m "Update versions.json: add $VERSION"
            git push origin HEAD:main || {
              echo "Warning: Failed to push versions.json update to main branch"
              echo "This may happen if main is protected or if there are conflicts"
              echo "You may need to manually update versions.json in the repository"
            }
          fi

          # Re-apply version substitution to manifest.json for build
          sed -i "s|__VERSION__|$VERSION|g" manifest.json
          echo "Re-applied version substitution to manifest.json for build"

      - name: Build plugin
        run: |
          set -e  # Exit immediately if a command fails
          npm install
          npm run build
          # Note: Playwright browsers are NOT needed for build, only for runtime provider automation
          # No need to run 'npx playwright install' here

      - name: Validate version consistency
        run: |
          set -e  # Exit immediately if a command fails
          manifest_version=$(jq -r '.version' manifest.json) || {
            echo "Error: Failed to read version from manifest.json"
            exit 1
          }

          if [ "$VERSION" != "$manifest_version" ]; then
            echo "Error: Expected version ($VERSION) does not match manifest.json version ($manifest_version)"
            exit 1
          fi
          echo "Version validation passed: $VERSION"

      - name: Verify build artifacts
        run: |
          set -e  # Exit immediately if a command fails
          # Check files exist
          test -f main.js || { echo "Error: main.js not found"; exit 1; }
          test -f manifest.json || { echo "Error: manifest.json not found"; exit 1; }
          test -f styles.css || { echo "Error: styles.css not found"; exit 1; }
          test -f versions.json || { echo "Error: versions.json not found"; exit 1; }

          # Check files are not empty
          test -s main.js || { echo "Error: main.js is empty"; exit 1; }
          test -s manifest.json || { echo "Error: manifest.json is empty"; exit 1; }
          test -s styles.css || { echo "Error: styles.css is empty"; exit 1; }
          test -s versions.json || { echo "Error: versions.json is empty"; exit 1; }

          # Validate JSON files
          jq empty manifest.json || { echo "Error: manifest.json is not valid JSON"; exit 1; }
          jq empty versions.json || { echo "Error: versions.json is not valid JSON"; exit 1; }

          echo "All required files present and valid"

      - name: Run tests
        run: npm test

      - name: Create release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e  # Exit immediately if a command fails
          # Verify gh CLI is available
          if ! command -v gh &> /dev/null; then
            echo "::error::gh CLI is not installed"
            exit 1
          fi

          # Build file list for release as an array to handle spaces safely
          files=(main.js manifest.json styles.css)

          # Verify versions.json exists (required for release)
          if [ ! -f versions.json ]; then
            echo "Error: versions.json not found"
            exit 1
          fi
          files+=(versions.json)

          # Create release with error handling
          # Use GIT_TAG (with 'v' prefix) for GitHub release name
          if ! gh release create "$GIT_TAG" \
            --title="$GIT_TAG" \
            --draft \
            --generate-notes \
            "${files[@]}"; then
            echo "::error::Failed to create release for tag $GIT_TAG"
            echo "::notice::The tag $GIT_TAG has been pushed but release creation failed."
            echo "::notice::You can manually create the release at: https://github.com/${{ github.repository }}/releases/new?tag=$GIT_TAG"
            exit 1
          fi

          echo "::notice::Draft release created successfully. Review and publish at: https://github.com/${{ github.repository }}/releases"
